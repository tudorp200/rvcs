use crate::commands::checkout;
use crate::commands::dec_object;
use crate::commands::{commit, diff};
use crate::others::file_altering;
use anyhow::Result;
use colored::*;
use std::collections::HashSet;
use std::fs;
use std::io::Write;
use std::path;

pub fn get_commit_ancestors(commit_hash: &str) -> Result<String> {
    let mut ancestors = String::new();
    let mut to_visit = vec![commit_hash.to_string()];

    while let Some(commit) = to_visit.pop() {
        ancestors.push_str(&commit);
        ancestors.push('\n');

        // Get all parents of the current commit
        let parents = file_altering::get_commit_parent(&commit)?;

        // Add parents to the list of commits to visit
        to_visit.extend(parents);
    }

    Ok(ancestors)
}

pub fn fast_forward_verif(branch1: &str, branch2: &str) -> Result<()> {
    let commit1 = file_altering::get_commit_from_branch(branch1)?;
    let commit2 = file_altering::get_commit_from_branch(branch2)?;
    let ancestors = get_commit_ancestors(&commit2)?;

    let mut flag = false;
    for line in ancestors.lines() {
        if commit1 == line {
            flag = true;
        }
    }
    if flag {
        return Ok(());
    }
    Err(anyhow::anyhow!("Cannot perform fast_forward_merge!"))
}

pub fn check_for_conflicts(tree1: &str, tree2: &str) -> Result<String> {
    let index1 = file_altering::build_index_from_tree(tree1)?;
    let index2 = file_altering::build_index_from_tree(tree2)?;
    let mut conflicts = String::new();
    let all_files: HashSet<String> = index1
        .obj
        .iter()
        .map(|obj| obj.path.to_str().unwrap().to_string())
        .chain(
            index2
                .obj
                .iter()
                .map(|obj| obj.path.to_str().unwrap().to_string()),
        )
        .collect();
    for file in all_files {
        let file1 = index1
            .obj
            .iter()
            .find(|obj| obj.path.to_str().unwrap() == file);
        let file2 = index2
            .obj
            .iter()
            .find(|obj| obj.path.to_str().unwrap() == file);
        if let (Some(branch1), Some(branch2)) = (file1, file2) {
            if branch1.hash != branch2.hash {
                conflicts.push_str(&file);
                let content1 = dec_object::dec_obj(&branch1.hash)?;
                let content2 = dec_object::dec_obj(&branch2.hash)?;
                let diff_output = crate::commands::diff::diff_between_content(&content1, &content2);
                conflicts.push('\n');
                conflicts.push_str(&diff_output);
            }
        }
    }

    Ok(conflicts)
}

pub fn fast_forward_merge(branch1: &str, branch2: &str, flag: bool) -> Result<()> {
    let commit1 = file_altering::get_commit_from_branch(branch1)?;
    let commit2 = file_altering::get_commit_from_branch(branch2)?;
    let diff_output = commit::detailed_print(&commit2, &commit1);
    let tree1 = file_altering::get_tree_from_commit(&commit1)?;
    let tree2 = file_altering::get_tree_from_commit(&commit2)?;
    if flag {
        let branch_path = path::Path::new(".vcs")
            .join("refs")
            .join("heads")
            .join(branch1);
        let mut branch_file = fs::File::create(branch_path)?;
        branch_file.write_all(&commit2.into_bytes())?;
        checkout::checkout(branch1)?;
        return Ok(());
    }
    let conflicts = check_for_conflicts(&tree1, &tree2)?;
    if !conflicts.is_empty() {
        let output = format!(
            "Conflicts in files: {}\n Conflicts are generated by branch: {}",
            conflicts.red(),
            branch2.red()
        );
        return Err(anyhow::anyhow!(output));
    }
    let branch_path = path::Path::new(".vcs")
        .join("refs")
        .join("heads")
        .join(branch1);
    let mut branch_file = fs::File::create(branch_path)?;
    branch_file.write_all(&commit2.into_bytes())?;
    checkout::checkout(branch1)?;
    println!(
        "<<<<<<<<<<{}>>>>>>>>>> <<<<<<<<<<{}>>>>>>>>>> \n {} \n",
        branch1.magenta().bold(),
        branch2.magenta().bold(),
        diff_output?.italic(),
    );
    Ok(())
}

/*
 * I need to write in branch1 the commit_hash of branch2
 * And practically to checkout to branch2 without actually changing the branch to branch2
 * only if there are no conflicts
 * The only conflict that can appear if the same file modified is in the two branches.
 * I will resolve this conflict by keeping everytime the file in the branch we merge to.
 * */

pub fn find_common_ancestor(branch1: &str, branch2: &str) -> Result<String> {
    let commit1 = file_altering::get_commit_from_branch(branch1)?;
    let commit2 = file_altering::get_commit_from_branch(branch2)?;
    let anc1 = get_commit_ancestors(&commit1)?;
    let anc2 = get_commit_ancestors(&commit2)?;

    for line1 in anc1.lines() {
        for line2 in anc2.lines() {
            if line1 == line2 {
                return Ok(line1.to_string());
            }
        }
    }
    Err(anyhow::anyhow!("No common ancestor found"))
}

use regex::Regex;

fn strip_ansi_codes(input: &str) -> String {
    // Regex to match ANSI escape codes
    let ansi_regex = Regex::new(r"\x1b\[[0-9;]*m").unwrap();
    ansi_regex.replace_all(input, "").to_string()
}

pub fn three_way_merge(branch1: &str, branch2: &str, flag: bool) -> Result<()> {
    // find common ancestors and get all the commits
    let commit_anc = find_common_ancestor(branch1, branch2)?;
    let commit1 = file_altering::get_commit_from_branch(branch1)?;
    let commit2 = file_altering::get_commit_from_branch(branch2)?;
    // get the trees form the commits
    let diff_output1 = commit::detailed_print(&commit1, &commit_anc);
    let diff_output2 = commit::detailed_print(&commit2, &commit_anc);
    let common_tree = file_altering::get_tree_from_commit(&commit_anc)?;
    let tree1 = file_altering::get_tree_from_commit(&commit1)?;
    let tree2 = file_altering::get_tree_from_commit(&commit2)?;

    if !flag {
        let conflicts1 = check_for_conflicts(&tree1, &common_tree)?;
        let mut conflicts2 = check_for_conflicts(&tree2, &common_tree)?;
        if conflicts2.is_empty() {
            let temp1 = diff::diff_between_commits(&commit_anc, &commit2)?;
            let temp2 = diff::diff_between_commits(&commit_anc, &commit1)?;
            let sections1 = commit::get_sections(&temp1)?;
            let sections2 = commit::get_sections(&temp2)?;

            let mut files1 = Vec::new();
            let mut files2 = Vec::new();
            for section in sections1.iter() {
                for line in section.iter() {
                    if line.starts_with("Added") {
                        let file_name = line["Added file: ".len()..].to_string();
                        files1.push(file_name);
                    }
                }
            }
            for section in sections2.iter() {
                for line in section.iter() {
                    if line.starts_with("Added") {
                        let file_name = line["Added file: ".len()..].to_string();
                        files2.push(file_name);
                    }
                }
            }
            for filename1 in files1.iter() {
                for filename2 in files2.iter() {
                    if filename1 == filename2 {
                        // i need to get the content of this files and than diff them
                        let index1 = file_altering::build_index_from_tree(&tree1)?;
                        let index2 = file_altering::build_index_from_tree(&tree2)?;
                        let file1 = index1.obj.iter().find(|obj| {
                            let t1 = strip_ansi_codes(filename1);
                            obj.path.to_str().unwrap() == t1
                        });
                        let file2 = index2.obj.iter().find(|obj| {
                            let t2 = strip_ansi_codes(filename2);
                            obj.path.to_str().unwrap() == t2
                        });
                        if let (Some(branch1), Some(branch2)) = (file1, file2) {
                            if branch1.hash != branch2.hash {
                                conflicts2.push_str(filename1);
                                let content1 = dec_object::dec_obj(&branch1.hash)?;
                                let content2 = dec_object::dec_obj(&branch2.hash)?;
                                let diff_output = crate::commands::diff::diff_between_content(
                                    &content1, &content2,
                                );
                                conflicts2.push('\n');
                                conflicts2.push_str(&diff_output);
                                conflicts2.push('\n');
                            }
                        }
                    }
                }
            }
        }
        match (conflicts1.is_empty(), conflicts2.is_empty()) {
            (false, false) => {
                let output = format!(
                    "Conflicts in files: \n {} \n {} \n Conflicts are generated the two branches",
                    conflicts1.red(),
                    conflicts2.red()
                );
                return Err(anyhow::anyhow!(output));
            }
            (true, false) => {
                let output = format!(
                    "Conflicts in files: \n {} \n {} \n Conflicts are generated by second branch",
                    conflicts1.green(),
                    conflicts2.red()
                );
                return Err(anyhow::anyhow!(output));
            }
            (false, true) => {
                let output = format!(
                    "Conflicts in files: \n {} \n {} \n Conflicts are generated by first branch",
                    conflicts1.green(),
                    conflicts2.red()
                );
                return Err(anyhow::anyhow!(output));
            }
            _ => {}
        }
    }
    commit::create_merge_commit(&commit1, &commit2)?;
    checkout::checkout(branch1)?;
    println!(
        "<<<<<<<<<<{}>>>>>>>>>> \n {} \n <<<<<<<<<<{}>>>>>>>>>> \n {}",
        branch1.magenta().bold(),
        diff_output1?.italic(),
        branch2.magenta().bold(),
        diff_output2?.italic()
    );
    Ok(())
}

pub fn merge(branch: &str, flag: bool) -> Result<()> {
    let current_branch = file_altering::get_curent_branch()?;
    let branch_name = &current_branch["refs/heads/".len()..];
    match fast_forward_verif(branch_name, branch) {
        Ok(_) => {
            println!("Performing fast forward merge!");
            fast_forward_merge(branch_name, branch, flag)?;
        }
        Err(_) => {
            println!("Performin three way merge!");
            three_way_merge(branch_name, branch, flag)?;
        }
    }
    Ok(())
}
